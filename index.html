<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rentry SVG Text Generator</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0a0a0f;
      --bg-card: #12121a;
      --bg-input: #1a1a25;
      --accent-pink: #ff69b4;
      --accent-cyan: #00ffff;
      --accent-purple: #a855f7;
      --text-primary: #ffffff;
      --text-secondary: #8888aa;
      --border-color: #2a2a3a;
      --glow-pink: rgba(255, 105, 180, 0.3);
      --glow-cyan: rgba(0, 255, 255, 0.3);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Space Mono', monospace;
      background: var(--bg-dark);
      color: var(--text-primary);
      min-height: 100vh;
      background-image: 
        radial-gradient(ellipse at 20% 20%, var(--glow-pink) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, var(--glow-cyan) 0%, transparent 50%);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    header {
      text-align: center;
      margin-bottom: 3rem;
    }

    h1 {
      font-family: 'Syne', sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-pink), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
    }

    @media (max-width: 900px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
      .output {
        position: static;
      }
    }

    @media (max-width: 600px) {
      .container {
        padding: 1rem;
      }
      h1 {
        font-size: 1.8rem;
      }
      .font-grid {
        grid-template-columns: 1fr;
      }
      .effects-grid {
        grid-template-columns: 1fr;
      }
      .animation-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .direction-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .color-row {
        flex-direction: column;
      }
      .toggle-group {
        flex-direction: column;
      }
      .toggle-btn {
        width: 100%;
      }
      .preview-area {
        min-height: 120px;
        padding: 1rem;
      }
    }

    .panel {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 1.5rem;
    }

    .panel-title {
      font-family: 'Syne', sans-serif;
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .section {
      margin-bottom: 1.5rem;
    }

    .section-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
    }

    /* Text Input */
    .text-input {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      color: var(--text-primary);
      font-family: 'Space Mono', monospace;
      font-size: 0.9rem;
      resize: vertical;
      min-height: 80px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .text-input:focus {
      outline: none;
      border-color: var(--accent-pink);
      box-shadow: 0 0 0 3px var(--glow-pink);
    }

    /* Font Grid */
    .font-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
      max-height: 200px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .font-grid::-webkit-scrollbar {
      width: 6px;
    }

    .font-grid::-webkit-scrollbar-track {
      background: var(--bg-input);
      border-radius: 3px;
    }

    .font-grid::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 3px;
    }

    .font-option {
      padding: 0.6rem 0.8rem;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.75rem;
      transition: all 0.2s;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .font-option:hover {
      border-color: var(--accent-cyan);
      background: rgba(0, 255, 255, 0.05);
    }

    .font-option.selected {
      border-color: var(--accent-pink);
      background: rgba(255, 105, 180, 0.1);
      box-shadow: 0 0 10px var(--glow-pink);
    }

    /* Color Mode Toggle */
    .toggle-group {
      display: flex;
      background: var(--bg-input);
      border-radius: 8px;
      padding: 4px;
      gap: 4px;
    }

    .toggle-btn {
      flex: 1;
      padding: 0.6rem 1rem;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-family: 'Space Mono', monospace;
      font-size: 0.8rem;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .toggle-btn.active {
      background: linear-gradient(135deg, var(--accent-pink), var(--accent-purple));
      color: white;
    }

    /* Color Pickers */
    .color-row {
      display: flex;
      gap: 1rem;
      align-items: center;
      margin-top: 1rem;
    }

    .color-picker-wrapper {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
    }

    .color-picker-wrapper label {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .color-picker {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: none;
    }

    .color-picker::-webkit-color-swatch-wrapper {
      padding: 0;
    }

    .color-picker::-webkit-color-swatch {
      border: 2px solid var(--border-color);
      border-radius: 6px;
    }

    .hex-input {
      width: 80px;
      padding: 0.5rem;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'Space Mono', monospace;
      font-size: 0.75rem;
    }

    /* Effects Grid */
    .effects-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }

    .effect-option {
      padding: 0.6rem;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.75rem;
      text-align: center;
      transition: all 0.2s;
    }

    .effect-option:hover {
      border-color: var(--accent-cyan);
    }

    .effect-option.selected {
      border-color: var(--accent-pink);
      background: rgba(255, 105, 180, 0.1);
    }

    /* Animation Options */
    .animation-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
    }

    .animation-option {
      padding: 0.6rem;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.7rem;
      text-align: center;
      transition: all 0.2s;
    }

    .animation-option:hover {
      border-color: var(--accent-cyan);
    }

    .animation-option.selected {
      border-color: var(--accent-pink);
      background: rgba(255, 105, 180, 0.1);
    }

    /* Sliders */
    .slider-group {
      margin-top: 1rem;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      background: var(--bg-input);
      border-radius: 3px;
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, var(--accent-pink), var(--accent-cyan));
      border-radius: 50%;
      cursor: pointer;
    }

    /* Number Input */
    .number-input {
      width: 70px;
      padding: 0.5rem;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'Space Mono', monospace;
      font-size: 0.8rem;
      text-align: center;
    }

    select.number-input {
      cursor: pointer;
      text-align: left;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238888aa'%3E%3Cpath d='M6 8L2 4h8z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      padding-right: 28px;
    }

    select.number-input option {
      background: var(--bg-input);
      color: var(--text-primary);
    }

    .inline-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .inline-group label {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    /* Sticky output panel */
    .output {
      position: sticky;
      top: 2rem;
      align-self: start;
    }

    /* Preview */
    .preview-area {
      background: linear-gradient(135deg, rgba(20, 20, 30, 0.9), rgba(30, 30, 45, 0.9));
      border: 1px solid var(--border-color);
      border-radius: 12px;
      min-height: 150px;
      max-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      margin-bottom: 1.5rem;
      overflow: hidden;
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    #previewContent {
      width: 100%;
      max-width: 100%;
      max-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #previewContent svg {
      max-width: 100%;
      overflow: hidden;
    }

    /* Code Output */
    .code-output {
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      font-size: 0.7rem;
      line-height: 1.6;
      max-height: 200px;
      overflow: auto;
      word-break: break-all;
      color: var(--accent-cyan);
    }

    .code-output::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    .code-output::-webkit-scrollbar-track {
      background: var(--bg-dark);
    }

    .code-output::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 3px;
    }

    /* Copy Button */
    .copy-btn {
      width: 100%;
      padding: 1rem;
      margin-top: 1rem;
      background: linear-gradient(135deg, var(--accent-pink), var(--accent-purple));
      border: none;
      border-radius: 8px;
      color: white;
      font-family: 'Syne', sans-serif;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .copy-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px var(--glow-pink);
    }

    .copy-btn:active {
      transform: translateY(0);
    }

    .copy-btn.copied {
      background: linear-gradient(135deg, #22c55e, #16a34a);
    }

    /* Checkbox */
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .checkbox-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent-pink);
    }

    .checkbox-group label {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    /* Gradient Direction */
    .direction-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .direction-btn {
      padding: 0.5rem;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .direction-btn:hover {
      border-color: var(--accent-cyan);
    }

    .direction-btn.selected {
      border-color: var(--accent-pink);
      background: rgba(255, 105, 180, 0.1);
      color: var(--text-primary);
    }

    /* Multiline toggle */
    .mode-toggle {
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>✧ Rentry SVG Text Generator ✧</h1>
      <p class="subtitle">Create fancy text effects for your Rentry pages</p>
    </header>

    <div class="main-grid">
      <!-- Left Panel: Controls -->
      <div class="controls">
        <!-- Text Input -->
        <div class="panel">
          <div class="panel-title">Text Input</div>
          
          <div class="section mode-toggle">
            <div class="toggle-group">
              <button class="toggle-btn active" data-mode="single" onclick="setTextMode('single')">Single Line</button>
              <button class="toggle-btn" data-mode="multi" onclick="setTextMode('multi')">Multi Line</button>
            </div>
          </div>

          <textarea class="text-input" id="textInput" placeholder="Type your text here...">Hello World</textarea>
          
          <div class="inline-group">
            <label>Font Size:</label>
            <input type="number" class="number-input" id="fontSize" value="18" min="8" max="200">
            <label>px</label>
          </div>
          <div class="inline-group">
            <label>Font Weight:</label>
            <select class="number-input" id="fontWeight" style="width: 100px;">
              <option value="100">100 Thin</option>
              <option value="200">200 ExtraLight</option>
              <option value="300">300 Light</option>
              <option value="400" selected>400 Normal</option>
              <option value="500">500 Medium</option>
              <option value="600">600 SemiBold</option>
              <option value="700">700 Bold</option>
              <option value="800">800 ExtraBold</option>
              <option value="900">900 Black</option>
            </select>
          </div>
          <div class="section" style="margin-top: 1rem; margin-bottom: 0;">
            <div class="section-label">Text Alignment</div>
            <div class="toggle-group">
              <button class="toggle-btn" data-align="left" onclick="setTextAlign('left')">Left</button>
              <button class="toggle-btn active" data-align="center" onclick="setTextAlign('center')">Center</button>
              <button class="toggle-btn" data-align="right" onclick="setTextAlign('right')">Right</button>
            </div>
          </div>
        </div>

        <!-- Font Selection -->
        <div class="panel">
          <div class="panel-title">Font Family</div>
          <div class="font-grid" id="fontGrid"></div>
        </div>

        <!-- Color Settings -->
        <div class="panel">
          <div class="panel-title">Color</div>
          
          <div class="section">
            <div class="section-label">Color Mode</div>
            <div class="toggle-group">
              <button class="toggle-btn active" data-color="solid" onclick="setColorMode('solid')">Solid</button>
              <button class="toggle-btn" data-color="gradient" onclick="setColorMode('gradient')">Gradient</button>
            </div>
          </div>

          <div id="solidColorSection" class="color-row" style="flex-direction: column; gap: 0.75rem;">
            <div style="display: flex; gap: 1rem; align-items: center;">
              <div class="color-picker-wrapper">
                <label>Color:</label>
                <input type="color" class="color-picker" id="solidColor" value="#ffffff">
                <input type="text" class="hex-input" id="solidColorHex" value="#ffffff">
              </div>
            </div>
            <div class="slider-group" style="margin-top: 0;">
              <div class="slider-label">
                <span>Opacity</span>
                <span id="solidOpacityValue">100%</span>
              </div>
              <input type="range" class="slider" id="solidOpacity" min="0" max="1" step="0.05" value="1">
            </div>
          </div>

          <div id="gradientColorSection" class="color-row" style="display: none; flex-direction: column; gap: 0.75rem;">
            <div style="display: flex; gap: 1rem;">
              <div class="color-picker-wrapper">
                <label>Start:</label>
                <input type="color" class="color-picker" id="gradientStart" value="#ff69b4">
                <input type="text" class="hex-input" id="gradientStartHex" value="#ff69b4">
              </div>
              <div class="color-picker-wrapper">
                <label>End:</label>
                <input type="color" class="color-picker" id="gradientEnd" value="#00ffff">
                <input type="text" class="hex-input" id="gradientEndHex" value="#00ffff">
              </div>
            </div>
            <div class="slider-group" style="margin-top: 0;">
              <div class="slider-label">
                <span>Opacity</span>
                <span id="gradientOpacityValue">100%</span>
              </div>
              <input type="range" class="slider" id="gradientOpacity" min="0" max="1" step="0.05" value="1">
            </div>
            <div class="section-label">Direction</div>
            <div class="direction-grid">
              <button class="direction-btn selected" data-dir="right" onclick="setGradientDir('right')">→</button>
              <button class="direction-btn" data-dir="left" onclick="setGradientDir('left')">←</button>
              <button class="direction-btn" data-dir="down" onclick="setGradientDir('down')">↓</button>
              <button class="direction-btn" data-dir="up" onclick="setGradientDir('up')">↑</button>
            </div>
          </div>
        </div>

        <!-- Effects -->
        <div class="panel">
          <div class="panel-title">Effects</div>
          
          <div class="section">
            <div class="section-label">Text Style</div>
            <div class="effects-grid">
              <div class="effect-option" data-effect="bold" onclick="toggleEffect('bold')">Bold</div>
              <div class="effect-option" data-effect="italic" onclick="toggleEffect('italic')">Italic</div>
              <div class="effect-option" data-effect="blur" onclick="toggleEffect('blur')">Blur</div>
            </div>
          </div>

          <div class="section">
            <div class="section-label">Underline</div>
            <div class="checkbox-group">
              <input type="checkbox" id="underlineEnabled" onchange="toggleDecoration('underline')">
              <label>Enable Underline</label>
            </div>
            <div id="underlineSettings" style="margin-top: 0.75rem; display: none;">
              <div class="section-label" style="margin-bottom: 0.5rem;">Style</div>
              <div class="effects-grid" style="grid-template-columns: repeat(3, 1fr);">
                <div class="effect-option underline-style selected" data-ulstyle="solid" onclick="setUnderlineStyle('solid')">Solid</div>
                <div class="effect-option underline-style" data-ulstyle="wavy" onclick="setUnderlineStyle('wavy')">Wavy</div>
                <div class="effect-option underline-style" data-ulstyle="dashed" onclick="setUnderlineStyle('dashed')">Dashed</div>
              </div>
              <div class="color-row" style="margin-top: 0.75rem;">
                <div class="color-picker-wrapper">
                  <label>Color:</label>
                  <input type="color" class="color-picker" id="underlineColor" value="#ffffff">
                </div>
                <div class="color-picker-wrapper">
                  <label>Thickness:</label>
                  <input type="number" class="number-input" id="underlineThickness" value="2" min="1" max="10">
                </div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-label">Overline</div>
            <div class="checkbox-group">
              <input type="checkbox" id="overlineEnabled" onchange="toggleDecoration('overline')">
              <label>Enable Overline</label>
            </div>
            <div id="overlineSettings" style="margin-top: 0.75rem; display: none;">
              <div class="section-label" style="margin-bottom: 0.5rem;">Style</div>
              <div class="effects-grid" style="grid-template-columns: repeat(3, 1fr);">
                <div class="effect-option overline-style selected" data-olstyle="solid" onclick="setOverlineStyle('solid')">Solid</div>
                <div class="effect-option overline-style" data-olstyle="wavy" onclick="setOverlineStyle('wavy')">Wavy</div>
                <div class="effect-option overline-style" data-olstyle="dashed" onclick="setOverlineStyle('dashed')">Dashed</div>
              </div>
              <div class="color-row" style="margin-top: 0.75rem;">
                <div class="color-picker-wrapper">
                  <label>Color:</label>
                  <input type="color" class="color-picker" id="overlineColor" value="#ffffff">
                </div>
                <div class="color-picker-wrapper">
                  <label>Thickness:</label>
                  <input type="number" class="number-input" id="overlineThickness" value="2" min="1" max="10">
                </div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-label">Text Transform</div>
            <div class="inline-group" style="margin-top: 0;">
              <label>Rotate:</label>
              <input type="number" class="number-input" id="textRotate" value="0" min="-180" max="180">
              <label>deg</label>
            </div>
            <div class="effects-grid" style="margin-top: 0.75rem;">
              <div class="effect-option" data-transform="flipH" onclick="toggleTransform('flipH')">Flip H</div>
              <div class="effect-option" data-transform="flipV" onclick="toggleTransform('flipV')">Flip V</div>
            </div>
          </div>

          <div class="section">
            <div class="section-label">Glow</div>
            <div class="checkbox-group">
              <input type="checkbox" id="glowEnabled" onchange="updatePreview()">
              <label>Enable Glow</label>
            </div>
            <div id="glowSettings" style="margin-top: 0.75rem;">
              <div class="color-row" style="margin-top: 0;">
                <div class="color-picker-wrapper">
                  <label>Color:</label>
                  <input type="color" class="color-picker" id="glowColor" value="#ff69b4">
                </div>
                <div class="color-picker-wrapper">
                  <label>Size:</label>
                  <input type="number" class="number-input" id="glowSize" value="5" min="1" max="20">
                </div>
              </div>
              <div class="slider-group">
                <div class="slider-label">
                  <span>Opacity</span>
                  <span id="glowOpacityValue">100%</span>
                </div>
                <input type="range" class="slider" id="glowOpacity" min="0" max="1" step="0.05" value="1">
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-label">Shadow</div>
            <div class="checkbox-group">
              <input type="checkbox" id="shadowEnabled" onchange="updatePreview()">
              <label>Enable Shadow</label>
            </div>
            <div id="shadowSettings" style="margin-top: 0.75rem;">
              <div class="color-row" style="margin-top: 0;">
                <div class="color-picker-wrapper">
                  <label>Color:</label>
                  <input type="color" class="color-picker" id="shadowColor" value="#000000">
                </div>
                <div class="color-picker-wrapper">
                  <label>Blur:</label>
                  <input type="number" class="number-input" id="shadowBlur" value="3" min="0" max="20">
                </div>
              </div>
              <div class="slider-group">
                <div class="slider-label">
                  <span>Opacity</span>
                  <span id="shadowOpacityValue">50%</span>
                </div>
                <input type="range" class="slider" id="shadowOpacity" min="0" max="1" step="0.05" value="0.5">
              </div>
              <div style="margin-top: 0.75rem;">
                <div class="section-label" style="margin-bottom: 0.5rem;">Position (px) - Use negative values to move up/left</div>
                <div style="display: flex; gap: 1rem;">
                  <div class="color-picker-wrapper">
                    <label>X:</label>
                    <input type="number" class="number-input" id="shadowX" value="2" min="-20" max="20">
                  </div>
                  <div class="color-picker-wrapper">
                    <label>Y:</label>
                    <input type="number" class="number-input" id="shadowY" value="2" min="-20" max="20">
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-label">Outline</div>
            <div class="checkbox-group">
              <input type="checkbox" id="outlineEnabled" onchange="updatePreview()">
              <label>Enable Outline</label>
            </div>
            <div class="color-row" id="outlineSettings" style="margin-top: 0.75rem;">
              <div class="color-picker-wrapper">
                <label>Color:</label>
                <input type="color" class="color-picker" id="outlineColor" value="#ffffff">
              </div>
              <div class="color-picker-wrapper">
                <label>Width:</label>
                <input type="number" class="number-input" id="outlineWidth" value="1" min="0.5" max="5" step="0.5">
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-label">Letter Spacing</div>
            <div class="slider-group">
              <div class="slider-label">
                <span>Spacing</span>
                <span id="spacingValue">0px</span>
              </div>
              <input type="range" class="slider" id="letterSpacing" min="0" max="20" value="0">
            </div>
          </div>
        </div>

        <!-- Animations -->
        <div class="panel">
          <div class="panel-title">Animation</div>
          
          <div class="section">
            <div class="section-label">Type</div>
            <div class="animation-grid" id="animationGrid">
              <div class="animation-option selected" data-anim="none" onclick="setAnimation('none')">None</div>
              <div class="animation-option" data-anim="bounce" onclick="setAnimation('bounce')">Bounce</div>
              <div class="animation-option" data-anim="pulse" onclick="setAnimation('pulse')">Pulse</div>
              <div class="animation-option" data-anim="glow-pulse" onclick="setAnimation('glow-pulse')">Glow Pulse</div>
              <div class="animation-option" data-anim="color-shift" onclick="setAnimation('color-shift')">Rainbow</div>
              <div class="animation-option" data-anim="float" onclick="setAnimation('float')">Float</div>
              <div class="animation-option" data-anim="wiggle" onclick="setAnimation('wiggle')">Wiggle</div>
              <div class="animation-option" data-anim="zoom" onclick="setAnimation('zoom')">Zoom</div>
              <div class="animation-option" data-anim="wave" onclick="setAnimation('wave')">Wave</div>
              <div class="animation-option" data-anim="marquee" onclick="setAnimation('marquee')">Marquee</div>
            </div>
          </div>

          <div class="slider-group" id="animationSpeed">
            <div class="slider-label">
              <span>Speed</span>
              <span id="speedValue">2s</span>
            </div>
            <input type="range" class="slider" id="animSpeed" min="0.5" max="10" step="0.5" value="2">
          </div>
        </div>
      </div>

      <!-- Right Panel: Preview & Output -->
      <div class="output">
        <div class="panel" style="height: 100%;">
          <div class="panel-title">Preview</div>
          <div class="preview-area" id="previewArea">
            <div id="previewContent"></div>
          </div>

          <div class="panel-title">Generated Code</div>
          <div class="code-output" id="codeOutput"></div>
          
          <button class="copy-btn" id="copyBtn" onclick="copyCode()">Copy Code</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Font definitions - Web-safe fonts that work across platforms
    const fonts = [
      // Serif fonts
      { name: 'Georgia', family: 'Georgia, serif', category: 'serif' },
      { name: 'Times New Roman', family: 'Times New Roman, Times, serif', category: 'serif' },
      { name: 'Palatino', family: 'Palatino Linotype, Palatino, serif', category: 'serif' },
      { name: 'Book Antiqua', family: 'Book Antiqua, Palatino, serif', category: 'serif' },
      { name: 'Garamond', family: 'Garamond, serif', category: 'serif' },
      { name: 'Cambria', family: 'Cambria, serif', category: 'serif' },
      { name: 'Didot', family: 'Didot, serif', category: 'serif' },
      { name: 'Bodoni MT', family: 'Bodoni MT, serif', category: 'serif' },
      // Sans-serif fonts
      { name: 'Arial', family: 'Arial, Helvetica, sans-serif', category: 'sans-serif' },
      { name: 'Verdana', family: 'Verdana, Geneva, sans-serif', category: 'sans-serif' },
      { name: 'Trebuchet MS', family: 'Trebuchet MS, sans-serif', category: 'sans-serif' },
      { name: 'Tahoma', family: 'Tahoma, Geneva, sans-serif', category: 'sans-serif' },
      { name: 'Helvetica', family: 'Helvetica, Arial, sans-serif', category: 'sans-serif' },
      { name: 'Impact', family: 'Impact, Charcoal, sans-serif', category: 'sans-serif' },
      { name: 'Arial Black', family: 'Arial Black, Gadget, sans-serif', category: 'sans-serif' },
      { name: 'Lucida Sans', family: 'Lucida Sans Unicode, Lucida Grande, sans-serif', category: 'sans-serif' },
      { name: 'Century Gothic', family: 'Century Gothic, sans-serif', category: 'sans-serif' },
      { name: 'Segoe UI', family: 'Segoe UI, sans-serif', category: 'sans-serif' },
      { name: 'Calibri', family: 'Calibri, sans-serif', category: 'sans-serif' },
      { name: 'Candara', family: 'Candara, sans-serif', category: 'sans-serif' },
      { name: 'Optima', family: 'Optima, sans-serif', category: 'sans-serif' },
      { name: 'Gill Sans', family: 'Gill Sans, sans-serif', category: 'sans-serif' },
      { name: 'Franklin Gothic', family: 'Franklin Gothic Medium, sans-serif', category: 'sans-serif' },
      // Monospace fonts
      { name: 'Courier New', family: 'Courier New, Courier, monospace', category: 'monospace' },
      { name: 'Lucida Console', family: 'Lucida Console, Monaco, monospace', category: 'monospace' },
      { name: 'Consolas', family: 'Consolas, monospace', category: 'monospace' },
      { name: 'Monaco', family: 'Monaco, monospace', category: 'monospace' },
      { name: 'Andale Mono', family: 'Andale Mono, monospace', category: 'monospace' },
      { name: 'Source Code Pro', family: 'Source Code Pro, monospace', category: 'monospace' },
      // Cursive/Script fonts
      { name: 'Comic Sans MS', family: 'Comic Sans MS, cursive', category: 'cursive' },
      { name: 'Lucida Handwriting', family: 'Lucida Handwriting, cursive', category: 'cursive' },
      { name: 'Segoe Script', family: 'Segoe Script, cursive', category: 'cursive' },
      { name: 'Brush Script MT', family: 'Brush Script MT, cursive', category: 'cursive' },
      { name: 'Snell Roundhand', family: 'Snell Roundhand, cursive', category: 'cursive' },
      // Fantasy/Decorative fonts
      { name: 'Papyrus', family: 'Papyrus, fantasy', category: 'fantasy' },
      { name: 'Copperplate', family: 'Copperplate, fantasy', category: 'fantasy' },
    ];

    // State
    let state = {
      text: 'Hello World',
      textMode: 'single',
      font: fonts[0],
      fontSize: 18,
      fontWeight: 400,
      textAlign: 'center',
      colorMode: 'solid',
      solidColor: '#ffffff',
      solidOpacity: 1,
      gradientStart: '#ff69b4',
      gradientEnd: '#00ffff',
      gradientDir: 'right',
      gradientOpacity: 1,
      effects: {
        bold: false,
        italic: false,
        blur: false
      },
      underline: {
        enabled: false,
        style: 'solid',
        color: '#ffffff',
        thickness: 2
      },
      overline: {
        enabled: false,
        style: 'solid',
        color: '#ffffff',
        thickness: 2
      },
      transform: {
        rotate: 0,
        flipH: false,
        flipV: false
      },
      glowEnabled: false,
      glowColor: '#ff69b4',
      glowSize: 5,
      glowOpacity: 1,
      shadowEnabled: false,
      shadowColor: '#000000',
      shadowOpacity: 0.5,
      shadowX: 2,
      shadowY: 2,
      shadowBlur: 3,
      outlineEnabled: false,
      outlineColor: '#ffffff',
      outlineWidth: 1,
      letterSpacing: 0,
      animation: 'none',
      animSpeed: 2
    };

    // Initialize font grid
    function initFontGrid() {
      const grid = document.getElementById('fontGrid');
      fonts.forEach((font, index) => {
        const option = document.createElement('div');
        option.className = 'font-option' + (index === 0 ? ' selected' : '');
        option.style.fontFamily = font.family;
        option.textContent = font.name;
        option.onclick = () => selectFont(index);
        grid.appendChild(option);
      });
    }

    function selectFont(index) {
      state.font = fonts[index];
      document.querySelectorAll('.font-option').forEach((el, i) => {
        el.classList.toggle('selected', i === index);
      });
      updatePreview();
    }

    function setTextMode(mode) {
      state.textMode = mode;
      document.querySelectorAll('[data-mode]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });
      updatePreview();
    }

    function setColorMode(mode) {
      state.colorMode = mode;
      document.querySelectorAll('[data-color]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === mode);
      });
      document.getElementById('solidColorSection').style.display = mode === 'solid' ? 'flex' : 'none';
      document.getElementById('gradientColorSection').style.display = mode === 'gradient' ? 'flex' : 'none';
      updatePreview();
    }

    function setGradientDir(dir) {
      state.gradientDir = dir;
      document.querySelectorAll('.direction-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.dir === dir);
      });
      updatePreview();
    }

    function toggleEffect(effect) {
      state.effects[effect] = !state.effects[effect];
      document.querySelector(`[data-effect="${effect}"]`).classList.toggle('selected');
      updatePreview();
    }

    function setAnimation(anim) {
      state.animation = anim;
      document.querySelectorAll('.animation-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.anim === anim);
      });
      updatePreview();
    }

    function setTextAlign(align) {
      state.textAlign = align;
      document.querySelectorAll('[data-align]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.align === align);
      });
      updatePreview();
    }

    function toggleDecoration(type) {
      if (type === 'underline') {
        state.underline.enabled = document.getElementById('underlineEnabled').checked;
        document.getElementById('underlineSettings').style.display = state.underline.enabled ? 'block' : 'none';
      } else if (type === 'overline') {
        state.overline.enabled = document.getElementById('overlineEnabled').checked;
        document.getElementById('overlineSettings').style.display = state.overline.enabled ? 'block' : 'none';
      }
      updatePreview();
    }

    function setUnderlineStyle(style) {
      state.underline.style = style;
      document.querySelectorAll('.underline-style').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.ulstyle === style);
      });
      updatePreview();
    }

    function setOverlineStyle(style) {
      state.overline.style = style;
      document.querySelectorAll('.overline-style').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.olstyle === style);
      });
      updatePreview();
    }

    function toggleTransform(type) {
      state.transform[type] = !state.transform[type];
      document.querySelector(`[data-transform="${type}"]`).classList.toggle('selected');
      updatePreview();
    }

    // Event listeners
    document.getElementById('textInput').addEventListener('input', (e) => {
      state.text = e.target.value;
      updatePreview();
    });

    document.getElementById('fontSize').addEventListener('input', (e) => {
      state.fontSize = parseInt(e.target.value) || 18;
      updatePreview();
    });

    document.getElementById('solidColor').addEventListener('input', (e) => {
      state.solidColor = e.target.value;
      document.getElementById('solidColorHex').value = e.target.value;
      updatePreview();
    });

    document.getElementById('solidColorHex').addEventListener('input', (e) => {
      if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
        state.solidColor = e.target.value;
        document.getElementById('solidColor').value = e.target.value;
        updatePreview();
      }
    });

    document.getElementById('gradientStart').addEventListener('input', (e) => {
      state.gradientStart = e.target.value;
      document.getElementById('gradientStartHex').value = e.target.value;
      updatePreview();
    });

    document.getElementById('gradientStartHex').addEventListener('input', (e) => {
      if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
        state.gradientStart = e.target.value;
        document.getElementById('gradientStart').value = e.target.value;
        updatePreview();
      }
    });

    document.getElementById('gradientEnd').addEventListener('input', (e) => {
      state.gradientEnd = e.target.value;
      document.getElementById('gradientEndHex').value = e.target.value;
      updatePreview();
    });

    document.getElementById('gradientEndHex').addEventListener('input', (e) => {
      if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
        state.gradientEnd = e.target.value;
        document.getElementById('gradientEnd').value = e.target.value;
        updatePreview();
      }
    });

    document.getElementById('solidOpacity').addEventListener('input', (e) => {
      state.solidOpacity = parseFloat(e.target.value);
      document.getElementById('solidOpacityValue').textContent = Math.round(state.solidOpacity * 100) + '%';
      updatePreview();
    });

    document.getElementById('gradientOpacity').addEventListener('input', (e) => {
      state.gradientOpacity = parseFloat(e.target.value);
      document.getElementById('gradientOpacityValue').textContent = Math.round(state.gradientOpacity * 100) + '%';
      updatePreview();
    });

    document.getElementById('glowEnabled').addEventListener('change', (e) => {
      state.glowEnabled = e.target.checked;
      updatePreview();
    });

    document.getElementById('glowColor').addEventListener('input', (e) => {
      state.glowColor = e.target.value;
      updatePreview();
    });

    document.getElementById('glowSize').addEventListener('input', (e) => {
      state.glowSize = parseInt(e.target.value) || 5;
      updatePreview();
    });

    document.getElementById('glowOpacity').addEventListener('input', (e) => {
      state.glowOpacity = parseFloat(e.target.value);
      document.getElementById('glowOpacityValue').textContent = Math.round(state.glowOpacity * 100) + '%';
      updatePreview();
    });

    document.getElementById('shadowEnabled').addEventListener('change', (e) => {
      state.shadowEnabled = e.target.checked;
      updatePreview();
    });

    document.getElementById('shadowColor').addEventListener('input', (e) => {
      state.shadowColor = e.target.value;
      updatePreview();
    });

    document.getElementById('shadowBlur').addEventListener('input', (e) => {
      state.shadowBlur = parseInt(e.target.value) || 3;
      updatePreview();
    });

    document.getElementById('shadowOpacity').addEventListener('input', (e) => {
      state.shadowOpacity = parseFloat(e.target.value);
      document.getElementById('shadowOpacityValue').textContent = Math.round(state.shadowOpacity * 100) + '%';
      updatePreview();
    });

    document.getElementById('shadowX').addEventListener('input', (e) => {
      state.shadowX = parseInt(e.target.value) || 0;
      updatePreview();
    });

    document.getElementById('shadowY').addEventListener('input', (e) => {
      state.shadowY = parseInt(e.target.value) || 0;
      updatePreview();
    });

    document.getElementById('outlineEnabled').addEventListener('change', (e) => {
      state.outlineEnabled = e.target.checked;
      updatePreview();
    });

    document.getElementById('outlineColor').addEventListener('input', (e) => {
      state.outlineColor = e.target.value;
      updatePreview();
    });

    document.getElementById('outlineWidth').addEventListener('input', (e) => {
      state.outlineWidth = parseFloat(e.target.value) || 1;
      updatePreview();
    });

    document.getElementById('letterSpacing').addEventListener('input', (e) => {
      state.letterSpacing = parseInt(e.target.value);
      document.getElementById('spacingValue').textContent = state.letterSpacing + 'px';
      updatePreview();
    });

    document.getElementById('animSpeed').addEventListener('input', (e) => {
      state.animSpeed = parseFloat(e.target.value);
      document.getElementById('speedValue').textContent = state.animSpeed + 's';
      updatePreview();
    });

    document.getElementById('fontWeight').addEventListener('change', (e) => {
      state.fontWeight = parseInt(e.target.value);
      updatePreview();
    });

    document.getElementById('underlineColor').addEventListener('input', (e) => {
      state.underline.color = e.target.value;
      updatePreview();
    });

    document.getElementById('underlineThickness').addEventListener('input', (e) => {
      state.underline.thickness = parseInt(e.target.value) || 2;
      updatePreview();
    });

    document.getElementById('overlineColor').addEventListener('input', (e) => {
      state.overline.color = e.target.value;
      updatePreview();
    });

    document.getElementById('overlineThickness').addEventListener('input', (e) => {
      state.overline.thickness = parseInt(e.target.value) || 2;
      updatePreview();
    });

    document.getElementById('textRotate').addEventListener('input', (e) => {
      state.transform.rotate = parseInt(e.target.value) || 0;
      updatePreview();
    });

    // Generate SVG code
    function generateCode() {
      const lines = state.textMode === 'multi' ? state.text.split('\n') : [state.text];
      const lineHeight = state.fontSize * 1.3;

      // Calculate better height with padding for effects
      const effectPadding = Math.max(
        state.glowEnabled ? state.glowSize * 2 : 0,
        state.shadowEnabled ? Math.abs(state.shadowY) + state.shadowBlur : 0,
        state.outlineEnabled ? state.outlineWidth * 2 : 0,
        state.animation === 'bounce' || state.animation === 'float' || state.animation === 'wave' ? 15 : 0,
        state.animation === 'zoom' ? state.fontSize * 0.15 : 0
      );
      const totalHeight = Math.ceil(lines.length * lineHeight + effectPadding * 2 + state.fontSize * 0.3);

      let styles = [];
      let defs = '';

      // Font
      styles.push(`font-family:${state.font.family}`);
      styles.push(`font-size:${state.fontSize}px`);

      // Font weight (use state.fontWeight if not using bold effect)
      if (state.effects.bold) {
        styles.push('font-weight:bold');
      } else if (state.fontWeight !== 400) {
        styles.push(`font-weight:${state.fontWeight}`);
      }

      // Color
      if (state.colorMode === 'gradient') {
        const dirs = {
          'right': { x1: '0%25', y1: '0%25', x2: '100%25', y2: '0%25' },
          'left': { x1: '100%25', y1: '0%25', x2: '0%25', y2: '0%25' },
          'down': { x1: '0%25', y1: '0%25', x2: '0%25', y2: '100%25' },
          'up': { x1: '0%25', y1: '100%25', x2: '0%25', y2: '0%25' }
        };
        const d = dirs[state.gradientDir];
        const gradOpacity = state.gradientOpacity < 1 ? ` stop-opacity='${state.gradientOpacity}'` : '';
        defs = `<defs><linearGradient id='g' x1='${d.x1}' y1='${d.y1}' x2='${d.x2}' y2='${d.y2}'><stop offset='0%25' stop-color='${state.gradientStart.replace('#', '%23')}'${gradOpacity}/><stop offset='100%25' stop-color='${state.gradientEnd.replace('#', '%23')}'${gradOpacity}/></linearGradient></defs>`;
        styles.push('fill:url%28%23g%29');
      } else {
        styles.push(`fill:${state.solidColor.replace('#', '%23')}`);
        if (state.solidOpacity < 1) {
          styles.push(`fill-opacity:${state.solidOpacity}`);
        }
      }

      // Outline
      if (state.outlineEnabled) {
        styles.push(`stroke:${state.outlineColor.replace('#', '%23')}`);
        styles.push(`stroke-width:${state.outlineWidth}`);
        styles.push('paint-order:stroke fill');
      }

      // Effects
      if (state.effects.italic) styles.push('font-style:italic');
      if (state.letterSpacing > 0) styles.push(`letter-spacing:${state.letterSpacing}px`);

      // Text decoration handled separately as SVG elements

      // Text transform (rotate, flip)
      let transforms = [];
      if (state.transform.rotate !== 0) {
        transforms.push(`rotate%28${state.transform.rotate}deg%29`);
      }
      if (state.transform.flipH) {
        transforms.push('scaleX%28-1%29');
      }
      if (state.transform.flipV) {
        transforms.push('scaleY%28-1%29');
      }

      // Filters
      let filters = [];
      let staticFilters = []; // Filters that should persist in glow-pulse animation
      if (state.effects.blur) filters.push('blur%281px%29');
      if (state.shadowEnabled) {
        const shadowColorWithOpacity = hexToRgba(state.shadowColor, state.shadowOpacity);
        const shadowFilter = `drop-shadow%28${state.shadowX}px ${state.shadowY}px ${state.shadowBlur}px ${shadowColorWithOpacity}%29`;
        filters.push(shadowFilter);
        staticFilters.push(shadowFilter);
      }
      if (state.glowEnabled) {
        const glowColorWithOpacity = hexToRgba(state.glowColor, state.glowOpacity);
        filters.push(`drop-shadow%280 0 ${state.glowSize}px ${glowColorWithOpacity}%29`);
      }

      // Animation - separate animation property from keyframes
      let animationProp = '';
      let animationKeyframes = '';
      const speed = state.animSpeed;

      switch (state.animation) {
        case 'bounce':
          animationProp = `animation:bounce ${speed}s ease-in-out infinite`;
          animationKeyframes = `@keyframes bounce{0%25,100%25{transform:translateY%280%29;}50%25{transform:translateY%28-5px%29;}}`;
          break;
        case 'pulse':
          animationProp = `animation:pulse ${speed}s ease-in-out infinite`;
          animationKeyframes = `@keyframes pulse{0%25,100%25{opacity:1;}50%25{opacity:0.5;}}`;
          break;
        case 'glow-pulse':
          const glowCol = state.glowColor.replace('#', '%23');
          // Preserve shadow filters while animating glow
          const baseFilters = staticFilters.length > 0 ? staticFilters.join(' ') + ' ' : '';
          animationProp = `animation:glowp ${speed}s ease-in-out infinite`;
          animationKeyframes = `@keyframes glowp{0%25,100%25{filter:${baseFilters}drop-shadow%280 0 2px ${glowCol}%29;}50%25{filter:${baseFilters}drop-shadow%280 0 10px ${glowCol}%29;}}`;
          filters = staticFilters.slice(); // Keep shadow filters
          break;
        case 'color-shift':
          animationProp = `animation:colorshift ${speed}s linear infinite`;
          animationKeyframes = `@keyframes colorshift{0%25{fill:%23ff69b4;}33%25{fill:%2300ffff;}66%25{fill:%23ffd700;}100%25{fill:%23ff69b4;}}`;
          break;
        case 'float':
          animationProp = `animation:float ${speed}s ease-in-out infinite`;
          animationKeyframes = `@keyframes float{0%25,100%25{transform:translateY%280%29;}50%25{transform:translateY%28-8px%29;}}`;
          break;
        case 'wiggle':
          // Wiggle handled specially to wrap in group for proper center
          break;
        case 'zoom':
          // Zoom handled specially to wrap in group for proper center
          break;
        case 'wave':
          // Wave animation is handled differently - per letter
          break;
        case 'marquee':
          // Marquee handled specially - forces single line
          break;
      }

      if (filters.length > 0 && state.animation !== 'glow-pulse') {
        styles.push(`filter:${filters.join(' ')}`);
      } else if (state.animation === 'glow-pulse' && staticFilters.length > 0) {
        // For glow-pulse, the filter is animated, not static
      }

      // Transforms will be applied to wrapper group (not text styles) so decorations rotate too
      // For marquee, skip rotation transforms
      let groupTransforms = [];
      if (state.animation !== 'marquee') {
        groupTransforms = transforms.slice();
      }

      // Animations that affect transform (bounce, float) go on wrapper group
      // Color-shift, glow-pulse, and pulse affect fill/filter/opacity so stay on text styles
      let groupAnimationCSS = '';
      let groupKeyframes = '';
      if (animationProp && ['bounce', 'float'].includes(state.animation)) {
        groupAnimationCSS = animationProp;
        groupKeyframes = animationKeyframes;
      } else if (animationProp && state.animation !== 'wave' && state.animation !== 'wiggle' &&
                 state.animation !== 'zoom' && state.animation !== 'marquee') {
        styles.push(animationProp);
        groupKeyframes = animationKeyframes; // Still need keyframes in extraStyles
      }

      // Build text elements
      let textContent = '';
      const textY = Math.ceil(effectPadding + state.fontSize);

      // Text anchor based on alignment
      let textAnchor = 'start';
      let textX = '0';
      if (state.textAlign === 'center') {
        textAnchor = 'middle';
        textX = '50%25';
      } else if (state.textAlign === 'right') {
        textAnchor = 'end';
        textX = '100%25';
      }

      // For marquee - force single line treatment (wave now supports multiline)
      const useMultiline = state.textMode === 'multi' && lines.length > 1 &&
                           state.animation !== 'marquee';
      const displayText = state.animation === 'marquee'
                          ? state.text.replace(/\n/g, ' ') : state.text;

      // Extra styles for animations that need them (wave, wiggle, zoom)
      let extraStyles = '';

      if (state.animation === 'wave') {
        // Wave animation: split text into individual letters (supports multiline)
        const delay = 0.1;
        let letterStyles = [];
        let letterCount = 0;

        if (useMultiline) {
          // Multiline wave: each line as separate text with wave letters
          lines.forEach((line, lineIdx) => {
            const lineY = textY + lineIdx * Math.ceil(lineHeight);
            let lineLetters = '';
            for (let i = 0; i < line.length; i++) {
              const char = escapeText(line[i] === ' ' ? '\u00A0' : line[i]);
              lineLetters += `<tspan class='l${letterCount}'>${char}</tspan>`;
              letterStyles.push(`.l${letterCount}{animation:wave ${speed}s ease-in-out infinite;animation-delay:${(letterCount * delay).toFixed(1)}s;}`);
              letterCount++;
            }
            textContent += `<text x='${textX}' y='${lineY}' text-anchor='${textAnchor}'>${lineLetters}</text>`;
          });
        } else {
          // Single line wave
          const text = displayText;
          let letterElements = '';
          for (let i = 0; i < text.length; i++) {
            const char = escapeText(text[i] === ' ' ? '\u00A0' : text[i]);
            letterElements += `<tspan class='l${i}'>${char}</tspan>`;
            letterStyles.push(`.l${i}{animation:wave ${speed}s ease-in-out infinite;animation-delay:${(i * delay).toFixed(1)}s;}`);
          }
          textContent = `<text x='${textX}' y='${textY}' text-anchor='${textAnchor}'>${letterElements}</text>`;
        }

        extraStyles = `${letterStyles.join('')}@keyframes wave{0%25,100%25{baseline-shift:0;}50%25{baseline-shift:10px;}}`;
      } else if (state.animation === 'marquee') {
        // Marquee: scrolling text animation
        const text = displayText;
        let marqueeStyles = styles.join(';');
        // Estimate text width for marquee
        const charWidth = state.fontSize * 0.6;
        const estTextWidth = text.length * charWidth + state.letterSpacing * (text.length - 1);
        const marqueeKeyframes = `@keyframes marquee{0%25{transform:translateX%28100%25%29;}100%25{transform:translateX%28-${estTextWidth}px%29;}}`;
        const marqueeAnim = `animation:marquee ${speed * 3}s linear infinite;`;
        textContent = `<text x='0' y='${textY}' text-anchor='start'>${escapeText(text)}</text>`;
        const allStyles = `text{${marqueeStyles};${marqueeAnim}}${marqueeKeyframes}`;
        const svg = `![](data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'>${defs}<style>/*<![CDATA[*/${allStyles}/*]]>*/</style>${textContent}</svg>){100%:${totalHeight}}`;
        return svg;
      } else if (state.animation === 'wiggle' || state.animation === 'zoom') {
        // Wiggle/zoom: generate text content, decorations will be added and wrapped later
        const animName = state.animation;
        const keyframes = animName === 'wiggle'
          ? `@keyframes ${animName}{0%25,100%25{transform:rotate%280deg%29;}25%25{transform:rotate%283deg%29;}75%25{transform:rotate%28-3deg%29;}}`
          : `@keyframes ${animName}{0%25,100%25{transform:scale%281%29;}50%25{transform:scale%281.1%29;}}`;
        // Store animation for wrapper - will be applied after decorations
        groupAnimationCSS = `animation:${animName} ${speed}s ease-in-out infinite;transform-origin:center;transform-box:fill-box`;
        extraStyles = keyframes;

        if (useMultiline) {
          const tspans = lines.map((line, i) => {
            return `<tspan x='${textX}' ${i === 0 ? `y='${textY}'` : `dy='${Math.ceil(lineHeight)}'`}>${escapeText(line)}</tspan>`;
          }).join('');
          textContent = `<text text-anchor='${textAnchor}'>${tspans}</text>`;
        } else {
          textContent = `<text x='${textX}' y='${textY}' text-anchor='${textAnchor}'>${escapeText(displayText)}</text>`;
        }
      } else if (useMultiline) {
        const tspans = lines.map((line, i) => {
          return `<tspan x='${textX}' ${i === 0 ? `y='${textY}'` : `dy='${Math.ceil(lineHeight)}'`}>${escapeText(line)}</tspan>`;
        }).join('');
        textContent = `<text text-anchor='${textAnchor}'>${tspans}</text>`;
      } else {
        textContent = `<text x='${textX}' y='${textY}' text-anchor='${textAnchor}'>${escapeText(displayText)}</text>`;
      }

      // Generate decoration elements (underline/overline) - supports multiline
      let decorationElements = '';
      if (state.underline.enabled || state.overline.enabled) {
        const charWidth = state.fontSize * 0.6;

        // Build wavy path helper
        function buildWavyPath(width, y, amp, wl) {
          const numSegments = Math.ceil((width * 2) / wl) + 2;
          let path = `M 0 ${y} q ${wl/4} ${-amp} ${wl/2} 0`;
          for (let i = 1; i < numSegments; i++) {
            path += ` t ${wl/2} 0`;
          }
          return path;
        }

        // Generate decoration for a single line
        function generateLineDecor(lineText, baseY, xOffset) {
          let decor = '';
          const lineWidth = lineText.length * charWidth + state.letterSpacing * Math.max(0, lineText.length - 1);
          const ulY = baseY + state.fontSize * 0.15;
          const olY = baseY - state.fontSize * 0.85;

          if (state.underline.enabled) {
            const ulColor = state.underline.color.replace('#', '%23');
            const ulThickness = state.underline.thickness;
            if (state.underline.style === 'wavy') {
              const amp = ulThickness * 1.5, wl = ulThickness * 4;
              decor += `<path d='${buildWavyPath(lineWidth, ulY, amp, wl)}' fill='none' stroke='${ulColor}' stroke-width='${ulThickness}' transform='translate%28${xOffset},0%29'/>`;
            } else {
              const dash = state.underline.style === 'dashed' ? ` stroke-dasharray='${ulThickness * 3} ${ulThickness * 2}'` : '';
              decor += `<line x1='${xOffset}' y1='${ulY}' x2='${xOffset + lineWidth}' y2='${ulY}' stroke='${ulColor}' stroke-width='${ulThickness}'${dash}/>`;
            }
          }
          if (state.overline.enabled) {
            const olColor = state.overline.color.replace('#', '%23');
            const olThickness = state.overline.thickness;
            if (state.overline.style === 'wavy') {
              const amp = olThickness * 1.5, wl = olThickness * 4;
              decor += `<path d='${buildWavyPath(lineWidth, olY, amp, wl)}' fill='none' stroke='${olColor}' stroke-width='${olThickness}' transform='translate%28${xOffset},0%29'/>`;
            } else {
              const dash = state.overline.style === 'dashed' ? ` stroke-dasharray='${olThickness * 3} ${olThickness * 2}'` : '';
              decor += `<line x1='${xOffset}' y1='${olY}' x2='${xOffset + lineWidth}' y2='${olY}' stroke='${olColor}' stroke-width='${olThickness}'${dash}/>`;
            }
          }
          return decor;
        }

        if (useMultiline) {
          // Generate decorations for each line
          lines.forEach((line, i) => {
            const lineY = textY + i * Math.ceil(lineHeight);
            const lineWidth = line.length * charWidth + state.letterSpacing * Math.max(0, line.length - 1);
            // Calculate x offset based on alignment
            let xOff = 0;
            // For multiline, we use percentage-based positioning via style
            decorationElements += `<g style='transform:translateX%28calc%28${state.textAlign === 'center' ? '50%25' : state.textAlign === 'right' ? '100%25' : '0%25'} - ${state.textAlign === 'center' ? lineWidth/2 : state.textAlign === 'right' ? lineWidth : 0}px%29%29'>${generateLineDecor(line, lineY, 0)}</g>`;
          });
        } else {
          // Single line
          const singleText = displayText.replace(/\n/g, ' ');
          const textWidth = singleText.length * charWidth + state.letterSpacing * Math.max(0, singleText.length - 1);
          decorationElements = generateLineDecor(singleText, textY, 0);
          // Wrap with alignment
          let decorStyle = '';
          if (state.textAlign === 'center') {
            decorStyle = ` style='transform:translateX%28calc%2850%25 - ${textWidth/2}px%29%29'`;
          } else if (state.textAlign === 'right') {
            decorStyle = ` style='transform:translateX%28calc%28100%25 - ${textWidth}px%29%29'`;
          }
          decorationElements = `<g${decorStyle}>${decorationElements}</g>`;
        }
      }

      const styleStr = styles.join(';');

      // Wrap text + decorations in group for transforms and animations
      let content = `${textContent}${decorationElements}`;
      let wrapperStyle = '';
      const wrapperParts = [];

      if (groupTransforms.length > 0) {
        wrapperParts.push(`transform:${groupTransforms.join(' ')}`);
        wrapperParts.push('transform-origin:center center');
        wrapperParts.push('transform-box:fill-box');
      }
      if (groupAnimationCSS) {
        wrapperParts.push(groupAnimationCSS);
      }

      if (wrapperParts.length > 0) {
        wrapperStyle = wrapperParts.join(';');
        content = `<g style='${wrapperStyle}'>${content}</g>`;
      }

      const allExtraStyles = extraStyles + groupKeyframes;
      const svg = `![](data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'>${defs}<style>/*<![CDATA[*/text{${styleStr}}${allExtraStyles}/*]]>*/</style>${content}</svg>){100%:${totalHeight}}`;

      return svg;
    }

    function escapeText(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29')
        .replace(/#/g, '%23');
    }

    function hexToRgba(hex, opacity) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      // URL encode for SVG data URI
      return `rgba%28${r},${g},${b},${opacity}%29`;
    }

    function hexToRgbaPlain(hex, opacity) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${opacity})`;
    }

    function updatePreview() {
      const code = generateCode();
      document.getElementById('codeOutput').textContent = code;

      // Generate preview SVG (without Rentry wrapper)
      const lines = state.textMode === 'multi' ? state.text.split('\n') : [state.text];
      const lineHeight = state.fontSize * 1.3;

      // Calculate better height with padding for effects
      const effectPadding = Math.max(
        state.glowEnabled ? state.glowSize * 2 : 0,
        state.shadowEnabled ? Math.abs(state.shadowY) + state.shadowBlur : 0,
        state.outlineEnabled ? state.outlineWidth * 2 : 0,
        state.animation === 'bounce' || state.animation === 'float' || state.animation === 'wave' ? 15 : 0,
        state.animation === 'zoom' ? state.fontSize * 0.15 : 0
      );
      const totalHeight = Math.ceil(lines.length * lineHeight + effectPadding * 2 + state.fontSize * 0.3);

      let styles = [];
      let defs = '';

      styles.push(`font-family:${state.font.family}`);
      styles.push(`font-size:${state.fontSize}px`);

      // Font weight
      if (state.effects.bold) {
        styles.push('font-weight:bold');
      } else if (state.fontWeight !== 400) {
        styles.push(`font-weight:${state.fontWeight}`);
      }

      if (state.colorMode === 'gradient') {
        const dirs = {
          'right': { x1: '0%', y1: '0%', x2: '100%', y2: '0%' },
          'left': { x1: '100%', y1: '0%', x2: '0%', y2: '0%' },
          'down': { x1: '0%', y1: '0%', x2: '0%', y2: '100%' },
          'up': { x1: '0%', y1: '100%', x2: '0%', y2: '0%' }
        };
        const d = dirs[state.gradientDir];
        const gradOpacity = state.gradientOpacity < 1 ? ` stop-opacity="${state.gradientOpacity}"` : '';
        defs = `<defs><linearGradient id="gp" x1="${d.x1}" y1="${d.y1}" x2="${d.x2}" y2="${d.y2}"><stop offset="0%" stop-color="${state.gradientStart}"${gradOpacity}/><stop offset="100%" stop-color="${state.gradientEnd}"${gradOpacity}/></linearGradient></defs>`;
        styles.push('fill:url(#gp)');
      } else {
        styles.push(`fill:${state.solidColor}`);
        if (state.solidOpacity < 1) {
          styles.push(`fill-opacity:${state.solidOpacity}`);
        }
      }

      // Outline
      if (state.outlineEnabled) {
        styles.push(`stroke:${state.outlineColor}`);
        styles.push(`stroke-width:${state.outlineWidth}`);
        styles.push('paint-order:stroke fill');
      }

      if (state.effects.italic) styles.push('font-style:italic');
      if (state.letterSpacing > 0) styles.push(`letter-spacing:${state.letterSpacing}px`);

      // Text transform
      let transforms = [];
      if (state.transform.rotate !== 0) {
        transforms.push(`rotate(${state.transform.rotate}deg)`);
      }
      if (state.transform.flipH) {
        transforms.push('scaleX(-1)');
      }
      if (state.transform.flipV) {
        transforms.push('scaleY(-1)');
      }

      let filters = [];
      let staticFilters = [];
      if (state.effects.blur) filters.push('blur(1px)');
      if (state.shadowEnabled) {
        const shadowColorWithOpacity = hexToRgbaPlain(state.shadowColor, state.shadowOpacity);
        const shadowFilter = `drop-shadow(${state.shadowX}px ${state.shadowY}px ${state.shadowBlur}px ${shadowColorWithOpacity})`;
        filters.push(shadowFilter);
        staticFilters.push(shadowFilter);
      }
      if (state.glowEnabled) {
        const glowColorWithOpacity = hexToRgbaPlain(state.glowColor, state.glowOpacity);
        filters.push(`drop-shadow(0 0 ${state.glowSize}px ${glowColorWithOpacity})`);
      }

      let animationProp = '';
      let animationKeyframes = '';
      const speed = state.animSpeed;

      switch (state.animation) {
        case 'bounce':
          animationProp = `animation:bounce ${speed}s ease-in-out infinite`;
          animationKeyframes = `@keyframes bounce{0%,100%{transform:translateY(0);}50%{transform:translateY(-5px);}}`;
          break;
        case 'pulse':
          animationProp = `animation:pulse ${speed}s ease-in-out infinite`;
          animationKeyframes = `@keyframes pulse{0%,100%{opacity:1;}50%{opacity:0.5;}}`;
          break;
        case 'glow-pulse':
          const baseFilters = staticFilters.length > 0 ? staticFilters.join(' ') + ' ' : '';
          animationProp = `animation:glowp ${speed}s ease-in-out infinite`;
          animationKeyframes = `@keyframes glowp{0%,100%{filter:${baseFilters}drop-shadow(0 0 2px ${state.glowColor});}50%{filter:${baseFilters}drop-shadow(0 0 10px ${state.glowColor});}}`;
          filters = staticFilters.slice();
          break;
        case 'color-shift':
          animationProp = `animation:colorshift ${speed}s linear infinite`;
          animationKeyframes = `@keyframes colorshift{0%{fill:#ff69b4;}33%{fill:#00ffff;}66%{fill:#ffd700;}100%{fill:#ff69b4;}}`;
          break;
        case 'float':
          animationProp = `animation:float ${speed}s ease-in-out infinite`;
          animationKeyframes = `@keyframes float{0%,100%{transform:translateY(0);}50%{transform:translateY(-8px);}}`;
          break;
        case 'wiggle':
        case 'zoom':
        case 'wave':
        case 'marquee':
          // Handled specially below
          break;
      }

      if (filters.length > 0 && state.animation !== 'glow-pulse') {
        styles.push(`filter:${filters.join(' ')}`);
      }

      // For marquee, skip rotation transforms
      let groupTransforms = [];
      if (state.animation !== 'marquee') {
        groupTransforms = transforms.slice();
      }

      // Animations that affect transform (bounce, float) go on wrapper group
      // Color-shift, glow-pulse, and pulse affect fill/filter/opacity so stay on text styles
      let groupAnimationCSS = '';
      let groupKeyframes = '';
      if (animationProp && ['bounce', 'float'].includes(state.animation)) {
        groupAnimationCSS = animationProp;
        groupKeyframes = animationKeyframes;
      } else if (animationProp && state.animation !== 'wave' && state.animation !== 'wiggle' &&
                 state.animation !== 'zoom' && state.animation !== 'marquee') {
        styles.push(animationProp);
        groupKeyframes = animationKeyframes;
      }

      // Text anchor based on alignment
      let textAnchor = 'start';
      let textX = '0';
      if (state.textAlign === 'center') {
        textAnchor = 'middle';
        textX = '50%';
      } else if (state.textAlign === 'right') {
        textAnchor = 'end';
        textX = '100%';
      }

      const textY = Math.ceil(effectPadding + state.fontSize);
      let textContent = '';
      let extraStyles = '';
      let allExtraStyles = '';

      // For marquee - force single line treatment
      const useMultiline = state.textMode === 'multi' && lines.length > 1 &&
                           state.animation !== 'marquee';
      const displayText = state.animation === 'marquee'
                          ? state.text.replace(/\n/g, ' ') : state.text;

      if (state.animation === 'wave') {
        // Wave supports multiline
        const delay = 0.1;
        let letterStyles = [];
        let letterCount = 0;
        let textElements = '';

        if (useMultiline) {
          lines.forEach((line, lineIdx) => {
            const lineY = textY + lineIdx * Math.ceil(lineHeight);
            let lineLetters = '';
            for (let i = 0; i < line.length; i++) {
              const char = escapeHTML(line[i] === ' ' ? '\u00A0' : line[i]);
              lineLetters += `<tspan class="l${letterCount}">${char}</tspan>`;
              letterStyles.push(`.l${letterCount}{animation:wave ${speed}s ease-in-out infinite;animation-delay:${(letterCount * delay).toFixed(1)}s;}`);
              letterCount++;
            }
            textElements += `<text x="${textX}" y="${lineY}" text-anchor="${textAnchor}">${lineLetters}</text>`;
          });
        } else {
          const text = displayText;
          let letterElements = '';
          for (let i = 0; i < text.length; i++) {
            const char = escapeHTML(text[i] === ' ' ? '\u00A0' : text[i]);
            letterElements += `<tspan class="l${i}">${char}</tspan>`;
            letterStyles.push(`.l${i}{animation:wave ${speed}s ease-in-out infinite;animation-delay:${(i * delay).toFixed(1)}s;}`);
          }
          textElements = `<text x="${textX}" y="${textY}" text-anchor="${textAnchor}">${letterElements}</text>`;
        }

        textContent = textElements;
        extraStyles = letterStyles.join('') + `@keyframes wave{0%,100%{baseline-shift:0;}50%{baseline-shift:10px;}}`;
      } else if (state.animation === 'marquee') {
        const text = displayText;
        const charWidth = state.fontSize * 0.6;
        const estTextWidth = text.length * charWidth + state.letterSpacing * (text.length - 1);
        textContent = `<text x="0" y="${textY}" text-anchor="start">${escapeHTML(text)}</text>`;
        extraStyles = `@keyframes marquee{0%{transform:translateX(100%);}100%{transform:translateX(-${estTextWidth}px);}}`;
        styles.push(`animation:marquee ${speed * 3}s linear infinite`);
      } else if (state.animation === 'wiggle' || state.animation === 'zoom') {
        const animName = state.animation;
        const keyframes = animName === 'wiggle'
          ? `@keyframes ${animName}{0%,100%{transform:rotate(0deg);}25%{transform:rotate(3deg);}75%{transform:rotate(-3deg);}}`
          : `@keyframes ${animName}{0%,100%{transform:scale(1);}50%{transform:scale(1.1);}}`;
        extraStyles = keyframes;
        // Store animation for wrapper - will be applied after decorations
        groupAnimationCSS = `animation:${animName} ${speed}s ease-in-out infinite;transform-origin:center;transform-box:fill-box;`;

        if (useMultiline) {
          const tspans = lines.map((line, i) => {
            return `<tspan x="${textX}" ${i === 0 ? `y="${textY}"` : `dy="${Math.ceil(lineHeight)}"`}>${escapeHTML(line)}</tspan>`;
          }).join('');
          textContent = `<text text-anchor="${textAnchor}">${tspans}</text>`;
        } else {
          textContent = `<text x="${textX}" y="${textY}" text-anchor="${textAnchor}">${escapeHTML(displayText)}</text>`;
        }
      } else if (useMultiline) {
        const tspans = lines.map((line, i) => {
          return `<tspan x="${textX}" ${i === 0 ? `y="${textY}"` : `dy="${Math.ceil(lineHeight)}"`}>${escapeHTML(line)}</tspan>`;
        }).join('');
        textContent = `<text text-anchor="${textAnchor}">${tspans}</text>`;
      } else {
        textContent = `<text x="${textX}" y="${textY}" text-anchor="${textAnchor}">${escapeHTML(displayText)}</text>`;
      }

      // Generate decoration elements for preview and supports multiline
      let decorationElements = '';
      if (state.underline.enabled || state.overline.enabled) {
        const charWidth = state.fontSize * 0.6;

        function buildWavyPathPreview(width, y, amp, wl) {
          const numSegments = Math.ceil((width * 2) / wl) + 2;
          let path = `M 0 ${y} q ${wl/4} ${-amp} ${wl/2} 0`;
          for (let i = 1; i < numSegments; i++) {
            path += ` t ${wl/2} 0`;
          }
          return path;
        }

        function generateLineDecorPreview(lineText, baseY, xOffset) {
          let decor = '';
          const lineWidth = lineText.length * charWidth + state.letterSpacing * Math.max(0, lineText.length - 1);
          const ulY = baseY + state.fontSize * 0.15;
          const olY = baseY - state.fontSize * 0.85;

          if (state.underline.enabled) {
            const ulColor = state.underline.color;
            const ulThickness = state.underline.thickness;
            if (state.underline.style === 'wavy') {
              const amp = ulThickness * 1.5, wl = ulThickness * 4;
              decor += `<path d="${buildWavyPathPreview(lineWidth, ulY, amp, wl)}" fill="none" stroke="${ulColor}" stroke-width="${ulThickness}" transform="translate(${xOffset},0)"/>`;
            } else {
              const dash = state.underline.style === 'dashed' ? ` stroke-dasharray="${ulThickness * 3} ${ulThickness * 2}"` : '';
              decor += `<line x1="${xOffset}" y1="${ulY}" x2="${xOffset + lineWidth}" y2="${ulY}" stroke="${ulColor}" stroke-width="${ulThickness}"${dash}/>`;
            }
          }
          if (state.overline.enabled) {
            const olColor = state.overline.color;
            const olThickness = state.overline.thickness;
            if (state.overline.style === 'wavy') {
              const amp = olThickness * 1.5, wl = olThickness * 4;
              decor += `<path d="${buildWavyPathPreview(lineWidth, olY, amp, wl)}" fill="none" stroke="${olColor}" stroke-width="${olThickness}" transform="translate(${xOffset},0)"/>`;
            } else {
              const dash = state.overline.style === 'dashed' ? ` stroke-dasharray="${olThickness * 3} ${olThickness * 2}"` : '';
              decor += `<line x1="${xOffset}" y1="${olY}" x2="${xOffset + lineWidth}" y2="${olY}" stroke="${olColor}" stroke-width="${olThickness}"${dash}/>`;
            }
          }
          return decor;
        }

        if (useMultiline) {
          lines.forEach((line, i) => {
            const lineY = textY + i * Math.ceil(lineHeight);
            const lineWidth = line.length * charWidth + state.letterSpacing * Math.max(0, line.length - 1);
            const alignStyle = state.textAlign === 'center' ? `calc(50% - ${lineWidth/2}px)` :
                               state.textAlign === 'right' ? `calc(100% - ${lineWidth}px)` : '0';
            decorationElements += `<g style="transform:translateX(${alignStyle})">${generateLineDecorPreview(line, lineY, 0)}</g>`;
          });
        } else {
          const singleText = displayText.replace(/\n/g, ' ');
          const textWidth = singleText.length * charWidth + state.letterSpacing * Math.max(0, singleText.length - 1);
          decorationElements = generateLineDecorPreview(singleText, textY, 0);
          let decorStyle = '';
          if (state.textAlign === 'center') {
            decorStyle = ` style="transform:translateX(calc(50% - ${textWidth/2}px))"`;
          } else if (state.textAlign === 'right') {
            decorStyle = ` style="transform:translateX(calc(100% - ${textWidth}px))"`;
          }
          decorationElements = `<g${decorStyle}>${decorationElements}</g>`;
        }
      }

      // Wrap text + decorations in group for transforms and animations
      let content = `${textContent}${decorationElements}`;
      const wrapperParts = [];

      if (groupTransforms.length > 0) {
        wrapperParts.push(`transform:${groupTransforms.join(' ')}`);
        wrapperParts.push('transform-origin:center center');
        wrapperParts.push('transform-box:fill-box');
      }
      if (groupAnimationCSS) {
        wrapperParts.push(groupAnimationCSS);
      }

      if (wrapperParts.length > 0) {
        content = `<g style="${wrapperParts.join(';')}">${content}</g>`;
      }

      allExtraStyles = extraStyles + groupKeyframes;
      const previewSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="${Math.max(totalHeight, 80)}">${defs}<style>text{${styles.join(';')}}${allExtraStyles}</style>${content}</svg>`;

      document.getElementById('previewContent').innerHTML = previewSVG;
    }

    function escapeHTML(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function copyCode() {
      const code = document.getElementById('codeOutput').textContent;
      navigator.clipboard.writeText(code).then(() => {
        const btn = document.getElementById('copyBtn');
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => {
          btn.textContent = 'Copy Code';
          btn.classList.remove('copied');
        }, 2000);
      });
    }

    initFontGrid();
    updatePreview();
  </script>
</body>
</html>